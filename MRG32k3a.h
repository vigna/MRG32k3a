/*  Written in 2019 by Sebastiano Vigna (vigna@acm.org)

To the extent possible under law, the author has dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.

See <http://creativecommons.org/publicdomain/zero/1.0/>. */

#include <stdint.h>

#pragma once

/**
 * A fast, testless implementation based on 64-bit integers of 
 * Pierre L'Ecuyer's pseudorandom number generator MRG32k3a 
 * (https://pubsonline.informs.org/doi/abs/10.1287/opre.47.1.159).
 *
 * There are three tests in the standard implementation of MRG32k3a: one test to
 * correct the combined output, and two tests to correct negative modular
 * residuals. In this implementation, the first test is avoided by
 * arithmetization, and the other two by ensuring that the argument to the
 * modulo operator is nonnegative, which is possible because of the small size
 * of the numbers involved.
 *
 * Additionally, the output value is computed on the *current* state, rather
 * then on the next state, to let the processor parallelize internally the
 * computation of the output value and of the next state.
 *
 * On an Intel(R) Core(TM) i7-7700 CPU @3.60GHz, using gcc 9.2.1 and my
 * standard harness (http://prng.di.unimi.it/harness.c) the double-based 
 * implementation (http://simul.iro.umontreal.ca/rng/MRG32k3a.c) takes
 * ~17.5ns to emit a double, the equivalent 64-bit integer implementation
 * takes ~7.9ns whereas this implementation needs just ~4.1ns.
 *
 * The stream generated by this implementation is identical to that of the
 * original one, provided that the initial state is set using the provided 
 * function MRG32k3a_init6(). An additional initialization function
 * MRG32k3a_init() provides a simpler way to set the initial state starting
 * from a 64-bit seed.
 *
 * Note that currently this implementation does not offer multiple streams, but
 * they could be implemented easily (e.g., borrowing the code from
 * https://github.com/umontreal-simul/ssj/blob/master/src/main/java/umontreal/ssj/rng/MRG32k3aL.java).
 */

extern int64_t __MRG32k3a_s10, __MRG32k3a_s11, __MRG32k3a_s12, __MRG32k3a_s20, __MRG32k3a_s21, __MRG32k3a_s22;

/** Initializes the generator starting from a 64-bit seed (using an underlying SplitMix64 generator). */
void MRG32k3a_init(const uint64_t s);

/** 
 * Initializes directly the generator state. The first three values must be in 
 * the range [0..4294967087) (not all zeros) and the last three values in the 
 * range [0..4294944443) (not all zeros).
 */

void MRG32k3a_init6(const uint32_t s10, const uint32_t s11, const uint32_t s12, const uint32_t s20, const uint32_t s21, const uint32_t s22);

/** Returns the next pseudorandom double in (0..1). */
static double inline MRG32k3a_next() {
	const int64_t m1 = INT64_C(4294967087);
	const int64_t m2 = INT64_C(4294944443);
	const int32_t a12 = INT32_C(1403580);
	const int32_t a13 = INT32_C(810728);
	const int32_t a21 = INT32_C(527612);
	const int32_t a23 = INT32_C(1370589);
	const int64_t corr1 = (m1 * a13);
	const int64_t corr2 = (m2 * a23);
	// This is equivalent to 2.328306549295727688e-10, but more precise as there's no rounding involved.
	const double norm = 0x1.000000d00000bp-32;

	int64_t p, r;

	/* Combination */
	r = __MRG32k3a_s12 - __MRG32k3a_s22;
	r -= m1 * ((r - 1) >> 63);

	/* Component 1 */
	p = (a12 * __MRG32k3a_s11 - a13 * __MRG32k3a_s10 + corr1) % m1;
	__MRG32k3a_s10 = __MRG32k3a_s11;
	__MRG32k3a_s11 = __MRG32k3a_s12;
	__MRG32k3a_s12 = p;

	/* Component 2 */
	p = (a21 * __MRG32k3a_s22 - a23 * __MRG32k3a_s20 + corr2) % m2;
	__MRG32k3a_s20 = __MRG32k3a_s21;
	__MRG32k3a_s21 = __MRG32k3a_s22;
	__MRG32k3a_s22 = p;

	return r * norm;
}
